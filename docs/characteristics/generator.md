---
title: Python 生成器
---

# Python 生成器

## 什么是生成器？

想象一下，你正在制作一份超大的披萨。

*   **传统方式：** 你一次性把所有配料都准备好，然后一股脑儿地铺在披萨饼上。这样做很简单粗暴，但是如果你的披萨饼太大了，配料太多了，可能会造成浪费，而且制作过程会很慢。
*   **生成器方式：** 你不是一次性准备好所有配料，而是每次需要的时候，才临时准备一点。比如，当披萨需要蘑菇的时候，你才切一点蘑菇；需要洋葱的时候，你才切一点洋葱。这样做的好处是，节省资源，而且可以更快地开始制作披萨。

**在 Python 中，生成器就像是“按需供应”的工具。它不会一次性生成所有数据，而是在你每次向它要数据的时候，才生成一个。**

## 为什么需要生成器？

*   **节省内存：** 如果你需要处理大量数据，一次性把所有数据都加载到内存中可能会导致内存溢出。生成器可以逐个生成数据，避免一次性加载所有数据。
*   **提高性能：** 生成器只在需要的时候才生成数据，避免了不必要的计算，从而提高了程序的性能。
*   **更简洁的代码：** 使用生成器可以简化代码，使代码更易于阅读和维护。

## 如何创建生成器？

创建生成器有两种主要方式：

1.  **生成器函数：** 使用 `yield` 关键字定义的函数。
2.  **生成器表达式：** 类似于列表推导式，但使用圆括号 `()`。

### 1. 生成器函数

**生成器函数** 是一种特殊的函数，它使用 `yield` 关键字来返回值。与普通函数不同的是，生成器函数在每次调用 `yield` 时都会暂停执行，并保存当前的状态。当再次调用生成器函数时，它会从上次暂停的地方继续执行。

**示例：**

```python
def my_generator(n):
  """一个简单的生成器函数，生成从 0 到 n-1 的整数"""
  for i in range(n):
    yield i

# 创建一个生成器对象
gen = my_generator(5)

# 逐个获取生成器生成的值
print(next(gen))  # 输出: 0
print(next(gen))  # 输出: 1
print(next(gen))  # 输出: 2
print(next(gen))  # 输出: 3
print(next(gen))  # 输出: 4

# 当生成器没有更多值时，会抛出 StopIteration 异常
# print(next(gen))  # 抛出 StopIteration 异常

# 也可以使用 for 循环遍历生成器
for i in my_generator(3):
  print(i)
# 输出:
# 0
# 1
# 2
```

**解释：**

*   `my_generator(n)` 是一个生成器函数，它接受一个参数 `n`。
*   `yield i` 语句会生成一个值 `i`，并暂停函数的执行。
*   `next(gen)` 函数用于从生成器中获取下一个值。
*   当生成器没有更多值时，`next(gen)` 会抛出 `StopIteration` 异常。
*   可以使用 `for` 循环遍历生成器，它会自动处理 `StopIteration` 异常。

**再来一个例子：**

```python
def fibonacci_generator(n):
  """生成斐波那契数列的前 n 个数"""
  a, b = 0, 1
  for _ in range(n):
    yield a
    a, b = b, a + b

# 打印斐波那契数列的前 10 个数
for num in fibonacci_generator(10):
  print(num, end=" ")
# 输出: 0 1 1 2 3 5 8 13 21 34
```

### 2. 生成器表达式

**生成器表达式** 是一种更简洁的创建生成器的方式。它类似于列表推导式，但使用圆括号 `()` 而不是方括号 `[]`。

**示例：**

```python
# 创建一个生成器表达式，生成 0 到 9 的平方
squares = (x * x for x in range(10))

# 逐个获取生成器生成的值
print(next(squares))  # 输出: 0
print(next(squares))  # 输出: 1
print(next(squares))  # 输出: 4

# 使用 for 循环遍历生成器
for square in squares:
  print(square, end=" ")
# 输出: 9 16 25 36 49 64 81
```

**解释：**

*   `(x * x for x in range(10))` 是一个生成器表达式，它会生成 0 到 9 的平方。
*   与列表推导式不同的是，生成器表达式不会立即计算所有值，而是只在需要的时候才计算。

**再来一个例子：**

```python
# 创建一个生成器表达式，生成所有偶数
even_numbers = (x for x in range(20) if x % 2 == 0)

# 打印所有偶数
for num in even_numbers:
  print(num, end=" ")
# 输出: 0 2 4 6 8 10 12 14 16 18
```

## 生成器的优势总结

*   **节省内存：** 避免一次性加载所有数据，特别适合处理大数据集。
*   **提高性能：** 只在需要时生成数据，避免不必要的计算。
*   **代码简洁：** 使用 `yield` 关键字或生成器表达式可以简化代码。
*   **可迭代性：** 可以使用 `for` 循环遍历生成器。

## 适用场景

*   **处理大型数据集：** 例如，读取大型日志文件、处理大型数据库查询结果。
*   **生成无限序列：** 例如，生成斐波那契数列、生成随机数。
*   **需要惰性计算的场景：** 例如，当计算结果只在特定条件下才需要时。

## 总结

生成器是 Python 中一个非常有用的工具，它可以帮助你编写更高效、更简洁的代码。希望通过这篇文章，你已经对生成器有了更深入的了解。记住，生成器就像一个“按需供应”的工厂，只有在你需要的时候，它才会生产产品！
