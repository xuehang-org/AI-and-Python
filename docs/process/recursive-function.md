---
title: Python 递归函数
---

# Python 递归函数

## 什么是递归？

简单来说，递归就是**函数自己调用自己**。  就像照镜子，镜子里有你，镜子里的你又有镜子，就这样无限循环下去（当然，实际的递归不能无限循环，需要有结束条件）。

## 递归的要素

一个递归函数通常包含两个关键部分：

1.  **基本情况（Base Case）：**  
    这是递归结束的条件。当满足基本情况时，函数停止调用自身，返回一个确定的值。如果没有基本情况，递归函数会无限循环，导致程序崩溃（Stack Overflow）。

2.  **递归情况（Recursive Case）：**  
    这是函数调用自身的部分。在递归情况中，函数会将问题分解成更小的子问题，并调用自身来解决这些子问题。

## 递归的原理

递归的本质是**将一个大问题分解成若干个相同的小问题**，然后通过解决小问题来最终解决大问题。  每次递归调用都会创建一个新的函数栈帧，用于存储函数的局部变量和状态。当递归到达基本情况时，函数开始逐层返回，并将结果传递给上一层函数，直到最终返回到最初的调用者。

## 为什么要用递归？

*   **代码简洁：**  
    对于某些问题，递归可以使代码更简洁易懂。
*   **解决复杂问题：**  
    递归非常适合解决那些可以自然分解成更小、相似子问题的问题，例如树的遍历、图的搜索等。

## 递归的缺点

*   **效率较低：**  
    递归通常比循环效率低，因为每次递归调用都需要创建新的函数栈帧，消耗时间和空间。
*   **容易栈溢出：**  
    如果递归深度过大，可能会导致栈溢出（Stack Overflow）。

## 递归示例

### 1. 阶乘

计算一个数的阶乘是递归的经典例子。

```python
def factorial(n):
  """
  计算阶乘 n!
  """
  # 基本情况：当 n 等于 0 或 1 时，阶乘为 1
  if n == 0 or n == 1:
    return 1
  # 递归情况：n! = n * (n-1)!
  else:
    return n * factorial(n - 1)

# 测试
print(factorial(5))  # 输出 120 (5*4*3*2*1)
print(factorial(0))  # 输出 1
print(factorial(1))  # 输出 1
```

**代码解释：**

*   `factorial(n)` 函数用于计算 `n` 的阶乘。
*   **基本情况：**  如果 `n` 是 0 或 1，函数直接返回 1。
*   **递归情况：**  否则，函数返回 `n * factorial(n - 1)`，即将问题分解为计算 `(n - 1)` 的阶乘的子问题。

### 2. 斐波那契数列

斐波那契数列也是一个适合用递归解决的例子。

```python
def fibonacci(n):
  """
  计算斐波那契数列的第 n 个数
  """
  # 基本情况：当 n 等于 0 或 1 时，返回 n
  if n == 0 or n == 1:
    return n
  # 递归情况：F(n) = F(n-1) + F(n-2)
  else:
    return fibonacci(n - 1) + fibonacci(n - 2)

# 测试
print(fibonacci(0))  # 输出 0
print(fibonacci(1))  # 输出 1
print(fibonacci(2))  # 输出 1
print(fibonacci(5))  # 输出 5
print(fibonacci(10)) # 输出 55
```

**代码解释：**

*   `fibonacci(n)` 函数用于计算斐波那契数列的第 `n` 个数。
*   **基本情况：**  如果 `n` 是 0 或 1，函数直接返回 `n`。
*   **递归情况：**  否则，函数返回 `fibonacci(n - 1) + fibonacci(n - 2)`，即将问题分解为计算第 `(n - 1)` 个和第 `(n - 2)` 个斐波那契数的子问题。

### 3. 列表求和

使用递归计算列表中所有元素的和。

```python
def sum_list(lst):
  """
  递归计算列表元素的和
  """
  # 基本情况：如果列表为空，返回 0
  if not lst:
    return 0
  # 递归情况：列表和 = 第一个元素 + 剩余元素的和
  else:
    return lst[0] + sum_list(lst[1:])

# 测试
my_list = [1, 2, 3, 4, 5]
print(sum_list(my_list))  # 输出 15
print(sum_list([]))  # 输出 0
```

**代码解释：**

*   `sum_list(lst)` 函数用于计算列表 `lst` 中所有元素的和。
*   **基本情况：**  如果列表为空（`not lst` 为 True），函数返回 0。
*   **递归情况：**  否则，函数返回 `lst[0] + sum_list(lst[1:])`，即将问题分解为计算列表第一个元素与剩余元素之和的子问题。  `lst[1:]` 表示从列表的第二个元素开始到末尾的所有元素，即列表的切片。

### 4.  反转字符串

使用递归反转字符串。

```python
def reverse_string(s):
  """
  递归反转字符串
  """
  # 基本情况：如果字符串为空或只有一个字符，直接返回
  if len(s) <= 1:
    return s
  # 递归情况：反转字符串 = 反转剩余部分 + 第一个字符
  else:
    return reverse_string(s[1:]) + s[0]

# 测试
my_string = "hello"
print(reverse_string(my_string))  # 输出 olleh
print(reverse_string(""))  # 输出 ""
print(reverse_string("a"))  # 输出 "a"
```

**代码解释：**

*   `reverse_string(s)` 函数用于反转字符串 `s`。
*   **基本情况：**  如果字符串为空或只有一个字符，函数直接返回该字符串。
*   **递归情况：**  否则，函数返回 `reverse_string(s[1:]) + s[0]`，即将问题分解为反转字符串的剩余部分，然后将其与第一个字符连接起来的子问题。

## 递归的注意事项

1.  **确保有基本情况：**  
    这是防止无限递归的关键。  一定要仔细考虑在什么情况下递归应该停止。

2.  **递归深度：**  
    Python 默认的递归深度有限制（通常是 1000 左右）。如果递归深度超过限制，会引发 `RecursionError`。  可以使用 `sys.setrecursionlimit()` 函数来修改递归深度，但是不建议设置过大，因为会消耗大量内存。

    ```python
    import sys
    sys.setrecursionlimit(2000) # 设置递归深度为2000
    ```

3.  **避免重复计算：**  
    在某些情况下，递归可能会导致重复计算，例如计算斐波那契数列时。  可以使用**记忆化（Memoization）**技术来避免重复计算，提高效率（后续会讲到）。

## 总结

递归是一种强大的编程技巧，可以使代码更简洁易懂。但是，递归也有其缺点，需要谨慎使用。  理解递归的关键是理解基本情况和递归情况，并确保递归能够最终到达基本情况。

希望这些例子能帮助你更好地理解 Python 中的递归函数！ 掌握递归需要多加练习，尝试用递归解决不同的问题。